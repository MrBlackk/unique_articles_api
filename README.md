Запуск сервісу на localhost:8080:
docker-compose up

API:
POST /articles, який приймає json {"content": "..."}
та повертає {"id": 5, "content": "...", "duplicate_article_ids": [1, 3]}

GET /articles/:id, який повертає статтю якщо існує
{"id": 3, "content": "...", "duplicate_article_ids": [1, 5]}

GET /articles, який повертає усі статті
{"articles": [
  {"id": 1, "content": "...", "duplicate_article_ids": [3, 5]},
  {"id": 2, "content": "...", "duplicate_article_ids": []},
  {"id": 3, "content": "...", "duplicate_article_ids": [1, 5]},
  {"id": 4, "content": "...", "duplicate_article_ids": []},
  {"id": 5, "content": "...", "duplicate_article_ids": [1, 3]}
]}

Методологія:
Перед тим як порівнювати тексти відкидаю часті слова (напр. "a", "an"), слова які легко замінювати (напр. "however", "indeed"),
також проводжу нормалізацію слова до однієї форми (напр. прибрати множину), синоніми приводжу до одного базового слова. Конфігуруються в filter_config.json файлі
Вважаю що порядок слів все ж є важливим.
За основу взяв модифікований алгоритм для пошуку відстані Левенштейна, з базою не буква а слово.
Відсоток дублікату конфігурується в config.json файлі

Речі на які б хотів звернути увагу:
БД: використовується in memory, але чисто в умовах завдання що запускаємо в докері однією командою, взагалі бажано б було використовувати звичайну
При знаходженні дублікатів записується дублікат до всіх записів які є дублікатами - не оптимально, не було часу вирішити проблему
Є шанс що при одночасних запитах можуть вичитатися застарілі статті
